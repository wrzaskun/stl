<!-- .slide: data-background="#111111" -->

# Kontenery asocjacyjne

___

## Posortowane

* <!-- .element: class="fragment fade-in" --> <code>set</code>
* <!-- .element: class="fragment fade-in" --> <code>multiset</code>
* <!-- .element: class="fragment fade-in" --> <code>map</code>
* <!-- .element: class="fragment fade-in" --> <code>multimap</code>

___

## NieuporzÄ…dkowane

* <!-- .element: class="fragment fade-in" --> <code>unordered_set</code>
* <!-- .element: class="fragment fade-in" --> <code>unordered_multiset</code>
* <!-- .element: class="fragment fade-in" --> <code>unordered_map</code>
* <!-- .element: class="fragment fade-in" --> <code>unordered_multimap</code>

___

## Quiz

Do czego moÅ¼esz uÅ¼yÄ‡:

* <!-- .element: class="fragment fade-in" --> <code>set</code>?
* <!-- .element: class="fragment fade-in" --> <code>multiset</code>?
* <!-- .element: class="fragment fade-in" --> <code>map</code>?
* <!-- .element: class="fragment fade-in" --> <code>multimap</code>?
* <!-- .element: class="fragment fade-in" --> <code>unordered_set</code>?
* <!-- .element: class="fragment fade-in" --> <code>unordered_multiset</code>?
* <!-- .element: class="fragment fade-in" --> <code>unordered_map</code>?
* <!-- .element: class="fragment fade-in" --> <code>unordered_multimap</code>?

___

## Notacja duÅ¼ego `O`

<img src="img/bigO.png">

___

## Cechy `std::map<K, T>` i `std::multimap<K, T>` #1

* <!-- .element: class="fragment fade-in" --> Forma drzewa binarnego (red-black tree)
* <!-- .element: class="fragment fade-in" --> Nie jest cache friendly
* <!-- .element: class="fragment fade-in" --> Pozwala przechowywaÄ‡ parÄ™ klucz-wartoÅ›Ä‡ (key-value)
* <!-- .element: class="fragment fade-in" --> Multimapa moÅ¼e mieÄ‡ wiele takich samych kluczy
* <!-- .element: class="fragment fade-in" --> Mapa ma unikatowe klucze
* <!-- .element: class="fragment fade-in" --> AlternatywÄ… dla multimapy jest <code>std::map&lt;key, std::vector&lt;value&gt;&gt;</code>

___
<!-- .slide: style="font-size: 0.95em" -->

## Cechy `std::map<K, T>` i `std::multimap<K, T>` #2

PoniewaÅ¼ jest ona zaimplementowana przewaÅ¼nie jako red-black tree (GNU standard C++ library) to czas wstawiania, usuwania i dodawania elementu to `O(log(n)`).

Zalety:
<!-- .element: class="fragment fade-in" -->

* <!-- .element: class="fragment fade-in" --> Szybkie wyszukiwanie elementÃ³w (kontenery sekwencyjnie <code>O(n)</code>),
* <!-- .element: class="fragment fade-in" --> WzglÄ™dnie szybki czas ich dodawania i usuwania np. <code>std::vector&lt;T&gt;</code> dodaje elementy w Å›rodku w czasie <code>O(n)</code>, ale <code>std::list&lt;T&gt;</code> (jeÅ¼eli mamy podany iterator) w czasie <code>O(1)</code>. StÄ…d mapa jest wzglÄ™dnie szybka zarÃ³wno w dodawaniu jak i usuwaniu.
* <!-- .element: class="fragment fade-in" --> Idealna, gdy czÄ™sto poszukujemy danych, a rzadziej je dodajemy lub usuwamy.

JeÅ¼eli bÄ™dziemy jej uÅ¼ywaÄ‡ jako zwykÅ‚ego kontenera, to stracimy na wydajnoÅ›ci. MapÄ™ naleÅ¼y stosowaÄ‡ wtedy, kiedy faktycznie chcemy posiadaÄ‡ pary klucz-wartoÅ›Ä‡ i czÄ™sto je wyszukiwaÄ‡. W innym przypadku moÅ¼emy uÅ¼yÄ‡ `std::vector<pair<K, V>>` lub innego kontenera.
<!-- .element: class="fragment fade-in" -->

___

## Operacje na `std::map<K, T>` i `std::multimap<K, T>`

* <!-- .element: class="fragment fade-in" --> dodawanie elementu: <code>insert()</code>, <code>emplace()</code>, <code>emplace_hint()</code>. Dodatkowo mapa posiada: <code>insert_or_assign()</code>, <code>try_emplace()</code> oraz <code>operator[]</code> (dodajÄ…co modyfikujÄ…cy)
* <!-- .element: class="fragment fade-in" --> modyfikowanie/dostÄ™p do elementu: <code>at()</code>, <code>operator[]</code> (Multimapa nie posiada takich opcji)
* <!-- .element: class="fragment fade-in" --> pierwszy/ostatni element: Brak
* <!-- .element: class="fragment fade-in" --> rozmiar/czy kontener jest pusty: <code>size()</code>, <code>empty()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* <!-- .element: class="fragment fade-in" --> iterator poczÄ…tku/koÅ„ca: <code>begin()</code>, <code>end()</code>

___

## Operacje na `std::map<K, T>` i `std::multimap<K, T>` #2

* <!-- .element: class="fragment fade-in" --> odwrÃ³cony (ang. reverse) iterator: <code>rbegin()</code>, <code>rend()</code>
* <!-- .element: class="fragment fade-in" --> staÅ‚y iterator: <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, <code>crend()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie kontenera: <code>clear()</code>
* <!-- .element: class="fragment fade-in" --> przygotowanie elementu do usuniÄ™cia: Brak
* <!-- .element: class="fragment fade-in" --> wymazanie elementÃ³w z pamiÄ™ci: <code>erase()</code>
* <!-- .element: class="fragment fade-in" --> podmiana caÅ‚ego kontenera: <code>swap()</code>
* <!-- .element: class="fragment fade-in" --> zliczenie elementÃ³w pasujÄ…cych do danego klucza: <code>count()</code> (dla mapy to 0 albo 1, dla multimapy od 0 do n)
* <!-- .element: class="fragment fade-in" --> odnalezienie elementu o podanym kluczu: <code>find()</code>

___

## PrzykÅ‚ad uÅ¼ycia `emplace_hint`

```cpp []
int main() {
    std::map<int, std::string> map;

    auto it = map.begin();
    map.emplace_hint(it, 10, "Ten");

    std::cout << map[10] << '\n';
}
```
<!-- .element: class="fragment fade-in" -->

Output:
`Ten`
<!-- .element: class="fragment fade-in" -->

Podpowiadamy mapie miejsce, gdzie powinna wstawiÄ‡ element, dziÄ™ki temu taka operacja bÄ™dzie miaÅ‚a zÅ‚oÅ¼onoÅ›Ä‡ `O(1)`. JeÅ¼eli jednak Åºle podpowiemy, to czas wstawienia bÄ™dzie `O(log(n))`. Raczej rzadko stosowane ğŸ™‚
<!-- .element: class="fragment fade-in" -->

___

### PrzykÅ‚ad uÅ¼ycia `insert_or_assign`

```cpp
int main() {
    std::map<int, std::string> map;

    auto it = map.begin();
    map.insert_or_assign(it, 10, "Ten");
    std::cout << map[10] << '\n';
    map.insert_or_assign(it, 10, "Dziesiec");
    std::cout << map[10] << '\n';
    map[10] = "Cent";
    std::cout << map[10] << '\n';
}
```
<!-- .element: class="fragment fade-in" -->

Output:
<!-- .element: class="fragment fade-in" -->

```cpp
Ten
Dziesiec
Cent
```
<!-- .element: class="fragment fade-in" -->

___

### PrzykÅ‚ad uÅ¼ycia `count`

```cpp
int main() {
    std::multimap<int, std::string> map;

    map.insert({5, "Five"});
    map.insert({5, "Funf"});
    map.insert({5, "Piec"});
    map.insert({5, "Cinq"});
    std::cout << map.count(5) << '\n';
}
```
<!-- .element: class="fragment fade-in" -->

Output: `4`
<!-- .element: class="fragment fade-in" -->

___

### PrzykÅ‚ad uÅ¼ycia `find`

```cpp
int main() {
    std::multimap<int, std::string> map;

    map.insert({5, "Five"});
    map.insert({5, "Funf"});
    map.insert({5, "Piec"});
    map.insert({5, "Cinq"});
    auto it = map.find(5);

    for (; it != map.end() ; ++it) {
        std::cout << it->first << " | " << it->second << '\n';
    }
}
```
<!-- .element: class="fragment fade-in" -->

Output:
<!-- .element: class="fragment fade-in" -->

```cpp
5 | Five
5 | Funf
5 | Piec
5 | Cinq
```
<!-- .element: class="fragment fade-in" -->

___

## Zadanie 1

* <!-- .element: class="fragment fade-in" --> StwÃ³rz multimapÄ™ i wypeÅ‚nij jÄ… podanymi wartoÅ›ciami

```cpp
map.insert({5, "Ala"});
map.insert({5, "Ma"});
map.insert({5, "Kota"});
map.insert({5, "A"});
map.insert({5, "Kot"});
map.insert({5, "Ma"});
map.insert({5, "Ale"});
```
<!-- .element: class="fragment fade-in" -->

* <!-- .element: class="fragment fade-in" --> Napisz funkcjÄ™, ktÃ³ra wyÅ›wietli sÅ‚owa w mapie o liczbie znakÃ³w rÃ³wnej 3.

___

## RozwiÄ…zanie

```cpp
std::vector<std::pair<int, std::string>> result;
std::copy_if(it,
             end(map),
             std::back_inserter(result),
             [](const auto& pair) { return pair.second.size() == 3; });
std::for_each(begin(result),
              end(result),
              [](const auto& pair) { std::cout << pair.second << '\n'; });
```
<!-- .element: class="fragment fade-in" -->

___

## Cechy `std::set<T>` i `std::multiset<T>` #1

* <!-- .element: class="fragment fade-in" --> Forma drzewa binarnego (red-black tree)
* <!-- .element: class="fragment fade-in" --> Nie jest cache friendly
* <!-- .element: class="fragment fade-in" --> Pozwala przechowywaÄ‡ wartoÅ›ci w uporzÄ…dkowanej kolejnoÅ›ci
* <!-- .element: class="fragment fade-in" --> Multiset moÅ¼e mieÄ‡ wiele takich samych wartoÅ›ci
* <!-- .element: class="fragment fade-in" --> Set ma unikatowe wartoÅ›ci
* <!-- .element: class="fragment fade-in" --> AlternatywÄ… dla multiset jest posortowany <code>std::vector&lt;T&gt;</code>

___
<!-- .slide: style="font-size: 0.95em" -->

## Cechy `std::set<T>` i `std::multiset<T>` #2

PoniewaÅ¼ jest on zaimplementowany przewaÅ¼nie jako red-black tree (GNU standard C++ library) to czas wstawiania, usuwania i dodawania elementu to `O(log(n)`).

Zalety:
<!-- .element: class="fragment fade-in" -->

* <!-- .element: class="fragment fade-in" --> Szybkie wyszukiwanie elementÃ³w (kontenery sekwencyjnie <code>O(n)</code>),
* <!-- .element: class="fragment fade-in" --> WzglÄ™dnie szybki czas ich dodawania i usuwania np. <code>std::vector&lt;T&gt;</code> dodaje elementy w Å›rodku w czasie <code>O(n)</code>, ale <code>std::list&lt;T&gt;</code> (jeÅ¼eli mamy podany iterator) w czasie <code>O(1)</code>. StÄ…d <code>set</code> jest wzglÄ™dnie szybki zarÃ³wno w dodawaniu jak i usuwaniu.
* <!-- .element: class="fragment fade-in" --> Idealny, gdy chcemy zawsze posiadaÄ‡ posortowane wartoÅ›ci.

JeÅ¼eli nie zaleÅ¼y nam, aby kontener byÅ‚ zawsze posortowany, lecz jedynie w specyficznych momentach, to moÅ¼e lepiej nam uÅ¼yÄ‡ `std::vector<T>` i sortowaÄ‡ go, gdy przyjdzie taka potrzeba. JeÅ¼eli teÅ¼ zaleÅ¼y nam tylko czasami na unikatowych wartoÅ›ciach, to moÅ¼emy wtedy uÅ¼yÄ‡ `std::unique()`.
<!-- .element: class="fragment fade-in" -->

___

## Operacje na `std::set<T>` i `std::multiset<T>`

* <!-- .element: class="fragment fade-in" --> dodawanie elementu: <code>insert()</code>, <code>emplace()</code>, <code>emplace_hint()</code>
* <!-- .element: class="fragment fade-in" --> modyfikowanie/dostÄ™p do elementu: Brak
* <!-- .element: class="fragment fade-in" --> pierwszy/ostatni element: Brak
* <!-- .element: class="fragment fade-in" --> rozmiar/czy kontener jest pusty: <code>size()</code>, <code>empty()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* <!-- .element: class="fragment fade-in" --> iterator poczÄ…tku/koÅ„ca: <code>begin()</code>, <code>end()</code>
* <!-- .element: class="fragment fade-in" --> odwrÃ³cony (ang. reverse) iterator: <code>rbegin()</code>, <code>rend()</code>

<!-- ciacham -->
___

## Operacje na `std::set<T>` i `std::multiset<T>` #2

* <!-- .element: class="fragment fade-in" --> staÅ‚y iterator: <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, <code>crend()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie kontenera: <code>clear()</code>
* <!-- .element: class="fragment fade-in" --> przygotowanie elementu do usuniÄ™cia: Brak
* <!-- .element: class="fragment fade-in" --> wymazanie elementÃ³w z pamiÄ™ci: <code>erase()</code>
* <!-- .element: class="fragment fade-in" --> podmiana caÅ‚ego kontenera: <code>swap()</code>
* <!-- .element: class="fragment fade-in" --> zliczenie elementÃ³w pasujÄ…cych do danego klucza: <code>count()</code> (dla <code>set</code> to 0 albo 1, dla <code>multiset</code> od 0 do n)
* <!-- .element: class="fragment fade-in" --> odnalezienie elementu o podanym kluczu: <code>find()</code>

___

## PrzykÅ‚ad uÅ¼ycia `std::set<T>`

```cpp
std::set<int> set {5, 4, 3, 2, 1, 0, 6, 8, 7};
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';

std::set<int, std::greater<int>> set2 {5, 4, 3, 2, 1, 0, 6, 8, 7};
for (const auto el : set2) {
    std::cout << el << ' ';
}
std::cout << '\n';
```
<!-- .element: class="fragment fade-in" -->

Output:
<!-- .element: class="fragment fade-in" -->

```cpp
0 1 2 3 4 5 6 7 8
8 7 6 5 4 3 2 1 0
```
<!-- .element: class="fragment fade-in" -->

___

## PrzykÅ‚ad uÅ¼ycia `std::multiset<T>`

```cpp
std::multiset<int> set {5, 4, 3, 2, 1, 0, 6, 8, 7, 1, 2, 3, 4, 5, 6};
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';

std::multiset<int, std::greater<int>> set2 {5, 4, 3, 2, 1, 0, 6, 8, 7, 1, 2, 3, 4, 5, 6};
for (const auto el : set2) {
    std::cout << el << ' ';
}
std::cout << '\n';
```
<!-- .element: class="fragment fade-in" -->

Output:
<!-- .element: class="fragment fade-in" -->

```cpp
0 1 1 2 2 3 3 4 4 5 5 6 6 7 8
8 7 6 6 5 5 4 4 3 3 2 2 1 1 0
```
<!-- .element: class="fragment fade-in" -->

___

## Hash Table

<img src="img/chainedHashing.png">

___
<!-- .slide: style="font-size: 0.8em" -->

## Funkcja mieszajÄ…ca

Jest to funkcja, ktÃ³ra z dowolnego obiektu wygeneruje nam index w tablicy. NajwaÅ¼niejszÄ… jej cechÄ… jest to, Å¼e zawsze dla takich samych danych wejÅ›ciowych musi wygenerowaÄ‡ ten sam index. KolejnÄ… waÅ¼nÄ… cechÄ… jest takie generowanie indexu, aby tylko dla jednej kombinacji mÃ³gÅ‚ on siÄ™ powtÃ³rzyÄ‡ np.:

```cpp
size_t hash(const std::string& str) { return str.size(); }
```
<!-- .element: class="fragment fade-in" -->

```cpp
size_t hash(const std::string& str) {
    size_t index = 0;
    for (size_t i = 0 ; i < str.size() ; ++i) {
        index += (int)str[i];
    }
    return index;
}
```
<!-- .element: class="fragment fade-in" -->

```cpp
size_t hash(const std::string& str) {
    size_t index = 0;
    for (size_t i = 0 ; i < str.size() - 1 ; ++i) {
        index += ((int)str[i] * int(str[i + 1]) * (i + 5)) & (((int)str[i] + int(str[i + 1]) * i * i));
    }
    return index * str.size();
}
```
<!-- .element: class="fragment fade-in" -->

OceÅ„ funkcje mieszajÄ…ce.
<!-- .element: class="fragment fade-in" -->
___

## Cechy `std::unordered_set<T>` i `std::unordered_multiset<T>` #1

* <!-- .element: class="fragment fade-in" --> Forma tablicy hash.
* <!-- .element: class="fragment fade-in" --> MoÅ¼e, ale nie musi byÄ‡ cache friendly. Hash table, czÄ™sto sÄ… tworzone w formie hybrydy <code>std::vector&lt;T&gt;</code> i <code>std::list&lt;T&gt;</code>.
* <!-- .element: class="fragment fade-in" --> WartoÅ›ci nie sÄ… posortowane
* <!-- .element: class="fragment fade-in" --> Multiset moÅ¼e mieÄ‡ wiele takich samych wartoÅ›ci
* <!-- .element: class="fragment fade-in" --> Set ma unikatowe wartoÅ›ci

___

## Cechy `std::unordered_set<T>` i `std::unordered_multiset<T>` #2

PoniewaÅ¼ jest on zaimplementowany jako hash table to Å›redni czas dodawania, usuwania, dostÄ™pu oraz modyfikacji to `O(1)`. Najgorszy dla wszystkich operacji czas to `O(n)`.

Zalety:
<!-- .element: class="fragment fade-in" -->

* <!-- .element: class="fragment fade-in" --> BÅ‚yskawiczne wyszukiwanie elementÃ³w
* <!-- .element: class="fragment fade-in" --> BÅ‚yskawicznie szybki czas ich dodawania i usuwania
* <!-- .element: class="fragment fade-in" --> OczywiÅ›cie przy zaÅ‚oÅ¼eniu, Å¼e mamy dobrÄ… funkcjÄ™ mieszajÄ…cÄ….

DoskonaÅ‚y dla kontenerÃ³w read-only. Czas odczytu `O(1)`.
DoskonaÅ‚y dla kontenerÃ³w majÄ…cych dobrÄ… funkcjÄ™ mieszajÄ…cÄ…. Czas dodawania, dostÄ™pu i modyfikacji `O(1)`.
<!-- .element: class="fragment fade-in" -->

___

## Operacje na `std::unordered_set<T>` i `std::unordered_multiset<T>`

* <!-- .element: class="fragment fade-in" --> dodawanie elementu: <code>insert()</code>, <code>emplace()</code>, <code>emplace_hint()</code>
* <!-- .element: class="fragment fade-in" --> modyfikowanie/dostÄ™p do elementu: Brak
* <!-- .element: class="fragment fade-in" --> pierwszy/ostatni element: Brak
* <!-- .element: class="fragment fade-in" --> rozmiar/czy kontener jest pusty: <code>size()</code>, <code>empty()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie nieuÅ¼ywanej pamiÄ™ci: Brak
* <!-- .element: class="fragment fade-in" --> iterator poczÄ…tku/koÅ„ca: <code>begin()</code>, <code>end()</code>
* <!-- .element: class="fragment fade-in" --> odwrÃ³cony (ang. reverse) iterator: Brak

___

## Operacje na `std::unordered_set<T>` i `std::unordered_multiset<T>` #2

* <!-- .element: class="fragment fade-in" --> staÅ‚y iterator: <code>cbegin()</code>, <code>cend()</code>
* <!-- .element: class="fragment fade-in" --> wyczyszczenie kontenera: <code>clear()</code>
* <!-- .element: class="fragment fade-in" --> przygotowanie elementu do usuniÄ™cia: Brak
* <!-- .element: class="fragment fade-in" --> wymazanie elementÃ³w z pamiÄ™ci: <code>erase()</code>
* <!-- .element: class="fragment fade-in" --> podmiana caÅ‚ego kontenera: <code>swap()</code>
* <!-- .element: class="fragment fade-in" --> zliczenie elementÃ³w pasujÄ…cych do danego klucza: <code>count()</code> (dla <code>set</code> to 0 albo 1, dla <code>multiset</code> od 0 do n)
* <!-- .element: class="fragment fade-in" --> odnalezienie elementu o podanym kluczu: <code>find()</code>

___

## PrzykÅ‚ad `std::unordered_set<T>` i `std::unordered_multiset<T>`

```cpp
std::unordered_set<std::string> set{"Ala", "Ma", "Kota", "A", "Kot", "Ma", "ALE"};
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';
set.insert("Ala");
set.insert("Ala");
set.insert("Ala");
for (const auto el : set) {
    std::cout << el << ' ';
}
std::cout << '\n';
```
<!-- .element: class="fragment fade-in" -->

___

## `unordered_map<K, T>` i `unordered_multimap<K, T>`

* <!-- .element: class="fragment fade-in" --> Zgadnij cechy,
* <!-- .element: class="fragment fade-in" --> Zgadnij implementacjÄ™,
* <!-- .element: class="fragment fade-in" --> WyÅ›lij przykÅ‚ad wykorzystujÄ…cy te 2 kontenery

___

## Zadanie 2

* <!-- .element: class="fragment fade-in" --> StwÃ³rz <code>std::unordered_map&lt;int, std::string&gt;</code> oraz <code>std::multiset&lt;int&gt;</code>
* <!-- .element: class="fragment fade-in" --> WypeÅ‚nij je dowolnymi wartoÅ›ciami
* <!-- .element: class="fragment fade-in" --> UsuÅ„ jeden z elementÃ³w,
* <!-- .element: class="fragment fade-in" --> dodaj dodatkowy element
* <!-- .element: class="fragment fade-in" --> UsuÅ„ elementy, wedÅ‚ug wymyÅ›lonego przez Ciebie predykatu.

___

## Q&A
